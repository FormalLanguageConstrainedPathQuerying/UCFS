{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"UCFS","text":"<p>Note: project under heavy development!</p>"},{"location":"#what-is-ucfs","title":"What is UCFS?","text":"<p>UCFS is an Universal Context-Free Solver: a GLL\u2011based tool for problems at the intersection of context\u2011free languages  over edge\u2011labeled directed graphs. Examples of such problems:</p> <ul> <li>Parsing</li> <li>Context-free path querying (CFPQ)</li> <li>Context-free language reachability (CFL-R)</li> <li>static code analysis </li> </ul> <p>Highlights</p> <ul> <li>Kotlin implementation with a concise Grammar DSL (EBNF\u2011friendly).</li> <li>Input: arbitrary edge\u2011labeled directed graphs.</li> <li>Output: SPPF -- finite structure for all\u2011paths queries.</li> </ul>"},{"location":"#repository-layout-highlevel","title":"Repository layout (high\u2011level)","text":"<pre><code>docs/         # documentation pages  \ngenerator/    # Parser &amp; AST node\u2011class generator &lt;in progress&gt;\nsolver/       # Core UCFS logic (GLL + RSM)\ntest-shared/  # Testcases, grammars, inputs, ANTLR4 comparison\n              # grammar examples and experiments\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>JDK 11+ (toolchain targets 11).  </li> <li>Gradle Wrapper included (<code>./gradlew</code>).</li> </ul>"},{"location":"#typical-workflow","title":"Typical workflow","text":"<p>1) Describe grammar in Kotlin DSL. 2) Load graph (for now <code>dot</code> format is supported). 3) Run query. 4) Inspect results.</p>"},{"location":"#core-algorithm","title":"Core Algorithm","text":"<p>UCFS is based on Generalized LL (GLL) parsing algorithm modified to handle language specification in form of Recursive State Machines (RSM-s) and input in form of arbitratry directed edge-labelled graph. Basic ideas described here. </p>"},{"location":"dsl/","title":"Domain Specific Language","text":"<p>The Universal Context-Free Solver provides an intuitive Kotlin-based inner DSL for defining and working with context-free grammars. It enables developers to describe grammars using natural Kotlin syntax while benefiting from:</p> <ul> <li>development tools and syntax analysis from scratch;</li> <li>simple (for now) compile-time checks for rules.</li> </ul>"},{"location":"dsl/#grammar","title":"Grammar","text":"<p>Each grammar is defined as a Kotlin class extending the base <code>Grammar</code> type and contains information about non-terminals, terminals, and production rules.</p> <p>For example, the following grammar defines a simple language that recognizes a single word \"a\":</p> <pre><code>class AGrammar : Grammar() {    \n        val S by Nt(\"a\").asStart()    \n}    \n</code></pre> <p>The start non-terminal can be set using the <code>setStart(nt)</code> method or directly during initialization with <code>Nt(...).asStart()</code>. Currently, only one start non-terminal is supported.</p>"},{"location":"dsl/#non-terminals","title":"Non-terminals","text":"<ul> <li>Designed as field of <code>Grammar</code> for easy monitoring and reuse.</li> <li>Declared using Kotlin property delegates, e.g., <code>val S by Nt()</code>.</li> <li>Initialization:</li> <li> <ul> <li>in corresponds delegate constructor <code>val AB by Nt(A or B)</code>;</li> </ul> </li> <li> <ul> <li>inside the <code>init</code> block using the <code>/=</code> operator, e.g., <code>AB /= A or B</code>.</li> </ul> </li> <li> <ul> <li>Each non-terminal must be initialized exactly once.</li> </ul> </li> </ul>"},{"location":"dsl/#terminals","title":"Terminals","text":"<ul> <li><code>Term</code> is a generic class that can store terminals of any type. For example: <pre><code>val A = Term(\"a\")\nval B = Term(42)\n</code></pre></li> <li>Terminals are compared based on their content value.</li> <li>Initialization:</li> <li> <ul> <li>as fields of grammar class, can be reused <code>val a = Temr(\"A\")</code>;</li> </ul> </li> <li> <ul> <li>directly in production <code>BA \\= Term(\"B\") * Term(\"A\")</code>.</li> </ul> </li> <li>Strings can be handled without wrapping. For instance, <code>digit \\= \"1\" or \"0\"</code>.</li> </ul>"},{"location":"dsl/#operations","title":"Operations","text":"Operation EBNF DSL Production A ::= B val A by Nt(B) \u00a0//in grammar class body  A \\= B \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 //in init block Concatenation A B A * B Alternatve A | B A or B Kleene Star \\(A^*\\) many(A) Kleene Star+ \\(A^+\\) some(A) Optional A | \\(\\varepsilon\\)  A? opt(A) <p>Epsilon (\\(\\varepsilon\\)) - constant terminal with behavior corresponding to the empty string.</p>"},{"location":"dsl/#examples","title":"Examples","text":""},{"location":"dsl/#dyck-language","title":"Dyck language","text":"<p>These grammars define the Dyck language \u2014 all correctly nested parentheses, brackets, and braces.</p>"},{"location":"dsl/#ebnf","title":"EBNF","text":"<pre><code>S = S1 | S2 | S3 | \u03b5    \nS1 = '(' S ')' S     \nS2 = '[' S ']' S     \nS3 = '{' S '}' S     \n</code></pre>"},{"location":"dsl/#dsl","title":"DSL","text":"<pre><code>class DyckGrammar : Grammar() {\n    val S       by Nt().asStart()\n    val Round   by Nt(\"(\" * S * \")\")\n    val Quadrat by Nt(\"[\" * S * \"]\")\n    val Curly   by Nt(\"{\" * S * \"}\")\n\n    init {\n        //recursive initialization can be only in `init` block\n        S /= S * (Round or Quadrat or Curly) or Epsilon\n    }\n}\n</code></pre>"},{"location":"dsl/#a-language","title":"A* language","text":""},{"location":"dsl/#ebnf_1","title":"EBNF","text":"<pre><code>A = \"a\"    \nS = A*     \n</code></pre>"},{"location":"dsl/#dsl_1","title":"DSL","text":"<p>Grammar for this language can be described in various ways. </p> <p><pre><code>class AStar : Grammar() {    \n        var A = Term(\"a\")    \n        val S by Nt().asStart(many(A))    \n    }    \n</code></pre> or  <pre><code>class AStar : Grammar() {    \n        val S by Nt().asStart()    \n        init {\n            S /= many(\"a\")\n        }\n    }    \n</code></pre></p>"}]}